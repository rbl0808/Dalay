- 数据类型

  1. String：缓存  计数器 共享用户Session

  2. Hash
  3. List：有序链表。消息队列  文章列表或者数据分页展示
  4. Set
  5. ZSet：排行榜
- 只有Zset和集群内部的节点数据结构 使用跳表
- select poll epoll
- 主从哨兵集群



为什么这么快

1. I/O多路复用
2. 单线程操作
3. 纯内存



键过期策略

1. **volatile-lru（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）

5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

   4.0 之后新增

7. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
8. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key



数据持久化

RDB和AOF

RDB  使用save(同步保存)或者bgsave(fork子进程)

三种不同的AOF

``` conf
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

AOF重写

BGREWRITEAOF

![文件重写流程](https://user-gold-cdn.xitu.io/2018/6/13/163f97f9bd0eea50?w=380&h=345&f=jpeg&s=14501)



Redis事务

Redis 可以通过 **MULTI，EXEC，DISCARD 和 WATCH**  等命令来实现事务(transaction)功能。

使用 [MULTI](https://redis.io/commands/multi)命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了[EXEC](https://redis.io/commands/exec)命令将执行所有命令。





缓存穿透和缓存雪崩

解决办法：

1. 缓存无效key
2. 布隆过滤器
3. 设置不同的过期时间，防止同一时间大量key失效



集群：主从-哨兵